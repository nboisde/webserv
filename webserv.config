
http    {
    server {
        listen          8080;
        server_name     webserv.com;
    }
    error_page      404 /404.html;
    location        = /404.html {
                    /www/html;}
    error_page      500 502 503 504 /50x.html;
    location        = /50x.html {
                    root /www/html; }
    client_max_body_size 100M;
    location / {
            root /share/html;
            index index.html;   
            autoindex on;
    }

}


◦ Le premier serveur pour un host :port sera le serveur par défaut pour cet
host :port (ce qui signifie qu’il répondra à toutes les requêtes qui n’appartiennent pas à un autre serveur)

◦ setup des routes avec une ou plusieurs des règles suivantes (les routes n’utiliseront pas de regexp) :
— définit une liste de méthodes HTTP acceptées pour la route
— définit une redirection HTTP.
— définit un répertoire ou un fichier à partir duquel le fichier doit être recherché (par exemple si l’url /kapouet est rooté sur /tmp/www, l’url /kapouet/pouic/toto/pouet est /tmp/www/pouic/toto/pouet )
— Un fichier par défaut comme réponse si la requête est un répertoire
— exécute CGI en fonction de certaines extensions de fichier (par exemple
.php)
— Vous vous demandez ce qu’est un CGI ?
— Parce que vous n’allez pas appeler le CGI utilisez directement le chemin
complet comme PATH_INFO
— Souvenez vous simplement que pour les requêtes fragmentées, votre serveur doit la dé-fragmenter et le CGI attendra EOF comme fin du body.
— Mêmes choses pour la sortie du CGI. si aucun content_length n’est
renvoyé par le CGI, EOF signifiera la fin des données renvoyées.
— Votre programme doit appeler le cgi avec le fichier demandé comme
premier argument
— le cgi doit être exécuté dans le bon répertoire pour l’accès au fichier de
chemin relatif
— votre serveur devrait fonctionner avec un seul CGI (php-cgi, python...)
6
Webserv C’est le moment de comprendre pourquoi les URLs commencent avec HTTP !
— rend la route capable d’accepter les fichiers téléchargés et configure où elle
doit être enregistrée
Vous devez fournir des fichiers de configuration et des fichiers de base par défaut pour
tester/démontrer que chaque fonctionnalité fonctionne pendant l’évaluation.





user www-data;
worker_processes  1;
error_log  /var/log/nginx/error.log;
pid        /var/run/nginx.pid;
events {
	worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type application/octet-stream;
    access_log  /var/log/nginx/access.log;
    sendfile        on;
    #tcp_nopush     on;
    #keepalive_timeout  0;
    keepalive_timeout  65;
    tcp_nodelay        on;
    # envoi moins d'information sur le serveur
    server_tokens off;

     # taille des buffers et taille max des requêtes normales
    client_body_buffer_size 1k;
    client_max_body_size    8m;
    large_client_header_buffers 1 1K;
    ignore_invalid_headers on;
    
    
    # définition des différents timeout
    client_body_timeout 5;
    client_header_timeout 5;
    keepalive_timeout 5 5;
    send_timeout 5;
    ignore_invalid_headers on;
    server_name_in_redirect off;
    
    
    # active la compression des pages sauf pour les navigateurs pourris
    gzip  on;
    gzip_comp_level 6;
    gzip_proxied any;
    gzip_vary on;
    gzip_types  text/plain text/css application/x-javascript;
    gzip_disable "MSIE [1-6]\.(?!.*SV1)";
    
    # limitation du nombre de connexion par client
    limit_zone gulag $binary_remote_addr 1m;
    limit_conn gulag 50;

    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}